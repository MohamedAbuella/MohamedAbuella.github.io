---
title: "Interactive Tool for Long-Term Planning: NPV and Payback for Energy Assets"
created_at: 2025-04-05 14:00:00 EST
author: Mohamed Abuella
layout: post
tags: [Blog]
---
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body {
            font-family: sans-serif;
            line-height: 1.5;
            padding: 20px;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
            table-layout: fixed;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
            overflow: hidden; /* Keep content from spilling */
            box-sizing: border-box;
            vertical-align: top; /* Align content to top */
        }
        th {
            background-color: #f2f2f2;
            position: sticky;
            top: 0;
            z-index: 10;
            white-space: normal; /* Allow header text to wrap */
            text-align: center; /* Center wrapped headers */
            font-weight: bold;
             hyphens: auto;
        }
        /* Column Widths - Adjusted */
         th:nth-child(1), td:nth-child(1) { width: 9%; }  /* Type */
         th:nth-child(2), td:nth-child(2) { width: 7%; }  /* Max GW (2025) - Editable */
         th:nth-child(3), td:nth-child(3) { width: 7%; }  /* Max GW (2050) - Editable */
         th:nth-child(4), td:nth-child(4) { width: 7%; }  /* Op Costs (£/MWh) */
         th:nth-child(5), td:nth-child(5) { width: 7%; }  /* Capex (£/MW) [ε] */
         th:nth-child(6), td:nth-child(6) { width: 7%; }  /* Fixed Cost Frac [φ] */
         th:nth-child(7), td:nth-child(7) { width: 6%; }  /* Econ Life (yrs) [n] */
         th:nth-child(8), td:nth-child(8) { width: 7%; }  /* Emissions (tCO2/MWh) [h] */
         th:nth-child(9), td:nth-child(9) { width: 6%; }  /* Discount Rate [r] */
         th:nth-child(10), td:nth-child(10){ width: 6%; }  /* Capacity Factor [CF] */
         th:nth-child(11), td:nth-child(11){ width: 8%; }  /* Invest (£m) */
         th:nth-child(12), td:nth-child(12){ width: 8%; }  /* Ann. Cash Flow (£m) */
         th:nth-child(13), td:nth-child(13){ width: 8%; }  /* NPV (£m) */
         th:nth-child(14), td:nth-child(14){ width: 7%; }  /* Payback (yrs) */


        /* Right-align numeric columns (GW, params, results) */
        td:nth-child(n+2) { /* Start from Max GW 2025 */
             text-align: right;
        }
        /* Style editable cells */
        td[contenteditable="true"] {
            background-color: #f0f8ff;
            cursor: cell;
            outline: none;
            border: 1px dashed #a0cfff;
        }
        td[contenteditable="true"]:focus {
            background-color: #e6f3ff;
             border: 1px solid #007bff;
             box-shadow: 0 0 3px rgba(0, 123, 255, 0.5);
        }
        /* Style result cells */
         .result-col {
             background-color: #e9ecef;
             font-weight: bold;
             text-align: right;
         }

        .controls {
            margin-bottom: 20px;
            padding: 15px;
            border: 1px solid #ccc;
            background-color: #f9f9f9;
            border-radius: 5px;
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 15px;
        }
        .controls label {
            font-weight: bold;
            white-space: nowrap;
        }
        .controls input[type="number"] {
            width: 80px;
            padding: 5px;
        }
        .controls .button-group {
             margin-left: auto;
             display: flex;
             gap: 10px;
        }
        .controls button {
            padding: 8px 15px;
            cursor: pointer;
        }
        .notes {
            margin-top: 20px;
            font-size: 0.9em;
            color: #555;
        }
        .positive-npv {
             color: green;
        }
        .negative-npv {
             color: red;
        }
        .table-container {
             max-height: 70vh;
             overflow: auto; /* Enable scrollbars */
             width: 100%;
        }
        .invalid-input {
            background-color: #ffdddd !important;
            border: 1px solid red !important;
        }
    </style>
</head>
<body>

    <h1>Techno-Economic Assessment of Energy Technologies: NPV & Payback Tool</h1>

    <div class="controls">
        <label for="electricityPrice">Avg. Electricity Price (£/MWh):</label>
        <input type="number" id="electricityPrice" value="100" step="1" onchange="updateAllCalculations()">

        <label for="carbonPrice">Carbon Price (£/tCO2):</label>
        <input type="number" id="carbonPrice" value="100" step="1" onchange="updateAllCalculations()">

        <label for="fixedCostFraction">Set All Fixed Cost Frac (φ):</label>
        <input type="number" id="fixedCostFraction" value="1.0" step="0.01" min="0" title="Set value for all rows in the 'Fixed Cost Frac' column">
        <button onclick="applyGlobalFixedCostFraction()" title="Apply this value to all rows">Apply φ</button>

        <div class="button-group">
             <button onclick="updateAllCalculations()">Recalculate All</button>
             <button onclick="resetData()">Reset Data</button>
        </div>
    </div>

    <div class="table-container">
        <table>
            <thead>
                <tr>
                    <th>Type</th>                      <!-- 1 -->
                    <th>Max GW (2025)</th>           <!-- 2 (Editable) -->
                    <th>Max GW (2050)</th>           <!-- 3 (Editable, used for Calc) -->
                    <th>Op Costs (£/MWh)</th>        <!-- 4 -->
                    <th>Capex (£/MW) [ε]</th>        <!-- 5 -->
                    <th>Fixed Cost Frac [φ]</th>     <!-- 6 -->
                    <th>Econ Life (yrs) [n]</th>     <!-- 7 -->
                    <th>Emissions (tCO2/MWh) [h]</th><!-- 8 -->
                    <th>Discount Rate [r]</th>       <!-- 9 -->
                    <th>Capacity Factor [CF]</th>    <!-- 10 -->
                    <th class="result-col">Invest (£m)</th>            <!-- 11 -->
                    <th class="result-col">Ann. Cash Flow (£m)</th>    <!-- 12 -->
                    <th class="result-col">NPV (£m)</th>               <!-- 13 -->
                    <th class="result-col">Payback (yrs)</th>          <!-- 14 -->
                </tr>
            </thead>
            <tbody id="resultsTableBody">
                <!-- Data will be populated here by JavaScript -->
            </tbody>
        </table>
    </div>

     <div class="notes">
        <h2>Notes & Assumptions:</h2>
        <ul>
             <li>**Interactivity:** Parameter cells (light blue background: Max GW (2025) through CF) are editable. Click to edit, press Enter or click outside to confirm.</li>
             <li>**Calculations:** Financial results (Investment, Cash Flow, NPV, Payback) are calculated based on the editable **'Max GW (2050)'** value (which is converted internally to MW). Changes to 'Max GW (2025)' or 'Type' do not affect these financial results.</li>
            <li>**Global Controls:** Avg. Electricity Price and Carbon Price apply to all technologies. Changing these triggers a recalculation for all rows.</li>
             <li>**Set All Fixed Cost Frac (φ):** Use the input and 'Apply φ' button to override the 'Fixed Cost Frac \[φ]' column for all technologies simultaneously. Individual cells in that column can still be edited afterwards.</li>
            <li>Investment is assumed upfront (Year 0).</li>
            <li>Revenue, Operational Costs (Variable & Fixed), and Carbon Costs are assumed constant over the economic lifetime.</li>
             <li>Annual Fixed Cost = Cell's φ * Cell's ε * (Cell's Max GW (2050) * 1000).</li>
            <li>Annual Variable Cost = Annual Generation * Op Costs (£/MWh).</li>
            <li>Annual Carbon Cost = Annual Generation * Emissions * Carbon Price.</li>
             <li>Annual Generation (MWh) = (Cell's Max GW (2050) * 1000) * CF * 8760 (hours/year).</li>
            <li>NPV = Present Value of (Annual Revenue - Annual Var Cost - Annual Fixed Cost - Annual Carbon Cost) over 'n' years - Initial Investment.</li>
             <li>Payback Period is the discounted time for cumulative cash flows to recover the initial investment. 'Never' indicates payback doesn't occur within the economic life or cash flow is non-positive. 'N/A' if no capacity.</li>
            <li>NPV, Investment and Annual Cash Flow are shown in millions (£m).</li>
            <li>Storage, P2G, G2G revenue/cost models are simplified; real-world operation is more complex.</li>
        </ul>
    </div>

    <script>
        const initialData = [
            { id: 1, type: 'Gas CCS',         'max_p_mw 2025': 0,    'max_p_mw 2050': 10000, costs: 5.16180266, epsilon: 2361000, phi: 1.000, economic_life: 25, emissions: 0.0319, discount_rate: 0.138, CF: 0.92 },
            { id: 2, type: 'Nuclear',         'max_p_mw 2025': 6800, 'max_p_mw 2050': 25000, costs: 10.57838661,epsilon: 5191000, phi: 1.000, economic_life: 40, emissions: 0, discount_rate: 0.095, CF: 0.9 },
            { id: 3, type: 'Offshore Wind',   'max_p_mw 2025': 15000,'max_p_mw 2050': 100000,costs: 7.054794521, epsilon: 1642000, phi: 1.000, economic_life: 23, emissions: 0, discount_rate: 0.089, CF: 0.5 },
            { id: 4, type: 'PV',              'max_p_mw 2025': 17000,'max_p_mw 2050': 70000, costs: 4.718417047, epsilon: 452000, phi: 1.000, economic_life: 25, emissions: 0, discount_rate: 0.058, CF: 0.15 },
            { id: 5, type: 'Biomass',         'max_p_mw 2025': 4600, 'max_p_mw 2050': 5000,  costs: 2.12918783, epsilon: 581000, phi: 1.000, economic_life: 25, emissions: 0.3188, discount_rate: 0.075, CF: 0.89 },
            { id: 6, type: 'Hydro ROR',       'max_p_mw 2025': 2500, 'max_p_mw 2050': 5000,  costs: 2.283105023, epsilon: 2000000, phi: 1.000, economic_life: 40, emissions: 0, discount_rate: 0.07, CF: 0.5 },
            { id: 7, type: 'Hydro reservoir', 'max_p_mw 2025': 2500, 'max_p_mw 2050': 5000,  costs: 2.490660025, epsilon: 2500000, phi: 1.000, economic_life: 40, emissions: 0, discount_rate: 0.07, CF: 0.55 },
            { id: 8, type: 'Storage',         'max_p_mw 2025': 3000, 'max_p_mw 2050': 20000, costs: 5.707762557, epsilon: 395000, phi: 1.000, economic_life: 20, emissions: 0, discount_rate: 0.07, CF: 0.3 },
            { id: 9, type: 'Other RES',       'max_p_mw 2025': 1000, 'max_p_mw 2050': 20000, costs: 8.818493151, epsilon: 1642000, phi: 1.000, economic_life: 23, emissions: 0, discount_rate: 0.089, CF: 0.4 },
            { id: 10, type: 'Onshore Wind',   'max_p_mw 2025': 16000,'max_p_mw 2050': 50000, costs: 8.818493151, epsilon: 1642000, phi: 1.000, economic_life: 23, emissions: 0, discount_rate: 0.089, CF: 0.4 },
            { id: 11, type: 'Micro CHP',      'max_p_mw 2025': 500,  'max_p_mw 2050': 1000,  costs: 2.283105023, epsilon: 581000, phi: 1.000, economic_life: 15, emissions: 0.3188, discount_rate: 0.075, CF: 0.83 },
            { id: 12, type: 'Industrial CHP', 'max_p_mw 2025': 5000, 'max_p_mw 2050': 5000,  costs: 2.283105023, epsilon: 581000, phi: 1.000, economic_life: 15, emissions: 0.3188, discount_rate: 0.075, CF: 0.83 },
            { id: 13, type: 'g2p(H2-CCGT)',   'max_p_mw 2025': 0,    'max_p_mw 2050': 10000, costs: 3.234398782, epsilon: 697000, phi: 1.000, economic_life: 25, emissions: 0, discount_rate: 0.075, CF: 0.6 },
            { id: 14, type: 'g2p(H2-OCGT)',   'max_p_mw 2025': 0,    'max_p_mw 2050': 10000, costs: 4.851598174, epsilon: 374000, phi: 1.000, economic_life: 30, emissions: 0, discount_rate: 0.075, CF: 0.2 },
            { id: 15, type: 'g2p(Fuel Cell)', 'max_p_mw 2025': 0,    'max_p_mw 2050': 10000, costs: 11.07305936,epsilon: 465000, phi: 1.000, economic_life: 30, emissions: 0, discount_rate: 0.1, CF: 0.5 },
            { id: 16, type: 'p2g',            'max_p_mw 2025': 500,  'max_p_mw 2050': 20000, costs: 11.07305936,epsilon: 465000, phi: 1.000, economic_life: 30, emissions: 0, discount_rate: 0.1, CF: 0.5 },
            { id: 17, type: 'g2g',            'max_p_mw 2025': 0,    'max_p_mw 2050': 15000, costs: 3.276927209, epsilon: 384000, phi: 1.000, economic_life: 40, emissions: 0.022, discount_rate: 0.1, CF: 0.85 }
        ];

        const typesToCapitalize = ['g2p(H2-CCGT)', 'g2p(H2-OCGT)', 'p2g', 'g2g'];

        const parameterKeysInTableOrder = [
             'type', 'max_p_mw 2025', 'max_p_mw 2050', 'costs', 'epsilon',
             'phi', 'economic_life', 'emissions', 'discount_rate', 'CF'
         ];
        const editableParamKeys = [
            'max_p_mw 2025', 'max_p_mw 2050', 'costs', 'epsilon', 'phi',
            'economic_life', 'emissions', 'discount_rate', 'CF'
         ];
        function getParamColumnIndex(key) { return parameterKeysInTableOrder.indexOf(key); }
        const resultColumnsStart = parameterKeysInTableOrder.length; // Results start after the last parameter column

        // --- Formatting Helpers ---
        function formatNumber(num, decimals = 2) { /* ... as before ... */
            if (isNaN(num) || !isFinite(num)) return 'N/A';
            return num.toLocaleString(undefined, { minimumFractionDigits: decimals, maximumFractionDigits: decimals });
        }
         function formatGW(num_mw) { /* ... as before ... */
             if (isNaN(num_mw) || !isFinite(num_mw)) return 'N/A';
             return (num_mw / 1000).toLocaleString(undefined, { minimumFractionDigits: 1, maximumFractionDigits: 1 });
         }
         function parseGW(gwString) { /* ... as before ... */
             if (typeof gwString !== 'string') return NaN;
             return parseFloat(gwString.trim().replace(/,/g, ''));
         }
        function formatPhi(num) { /* ... as before ... */
             if (isNaN(num) || !isFinite(num)) return 'N/A';
             return num.toFixed(3);
        }
        function formatPayback(value) { /* ... as before ... */
            if (typeof value === 'string') return value;
            if (isNaN(value) || !isFinite(value)) return 'Error';
            return value.toFixed(2);
        }

        // --- Calculation Logic (with Payback change) ---
        function calculateRowResults(row) {
            const cells = row.cells;
            let inputParams = {};
            let isValid = true;
            let capacityMW = NaN;

            // Read editable inputs
            for (const key of editableParamKeys) {
                const index = getParamColumnIndex(key);
                if (index === -1) { console.error("Idx not found:", key); isValid = false; continue; }
                const cell = cells[index];
                const rawValue = cell.textContent;
                let value; let cellIsInvalid = false;
                if (key === 'max_p_mw 2025' || key === 'max_p_mw 2050') {
                    value = parseGW(rawValue);
                    if (isNaN(value) || value < 0) cellIsInvalid = true;
                    else if (key === 'max_p_mw 2050') capacityMW = value * 1000;
                    inputParams[key] = value;
                } else {
                    value = parseFloat(rawValue.trim().replace(/,/g, ''));
                    if (isNaN(value)) cellIsInvalid = true;
                    else if (key === 'economic_life' && (!Number.isInteger(value) || value <= 0)) cellIsInvalid = true;
                    else if (key === 'phi' && value < 0) cellIsInvalid = true;
                    else if (key === 'CF' && (value < 0 || value > 1)) cellIsInvalid = true;
                    inputParams[key] = value;
                }
                if (cellIsInvalid) { isValid = false; cell.classList.add('invalid-input'); }
                else cell.classList.remove('invalid-input');
            }

            // Check global prices & capacityMW
            const electricityPriceInput = document.getElementById('electricityPrice');
            const carbonPriceInput = document.getElementById('carbonPrice');
            const electricityPrice = parseFloat(electricityPriceInput.value);
            const carbonPrice = parseFloat(carbonPriceInput.value);
            if (isNaN(electricityPrice)) { isValid = false; electricityPriceInput.classList.add('invalid-input'); } else electricityPriceInput.classList.remove('invalid-input');
            if (isNaN(carbonPrice)) { isValid = false; carbonPriceInput.classList.add('invalid-input'); } else carbonPriceInput.classList.remove('invalid-input');
             if (isNaN(capacityMW)) {
                 isValid = false; const gw2050Index = getParamColumnIndex('max_p_mw 2050');
                 if (gw2050Index !== -1) cells[gw2050Index].classList.add('invalid-input');
             }

             // Clear results if invalid
             if (!isValid) {
                 for (let i = resultColumnsStart; i < cells.length; i++) {
                     cells[i].textContent = 'Error';
                     if (i === resultColumnsStart + 2) cells[i].classList.remove('positive-npv', 'negative-npv');
                 } return;
             }

            // Destructure & calculations
            const { costs: opCostPerMwh, epsilon, phi, economic_life: n, emissions, discount_rate: r, CF: cf } = inputParams;
            const capacity = capacityMW;
            let investment = 0, annualGeneration = 0, annualRevenue = 0, annualVarCost = 0, annualFixedCost = 0, annualCarbonCost = 0, annualNetCashFlow = 0, npv = 0, payback = 'N/A';

            if (capacity > 0 && n > 0 && !isNaN(capacity) && !isNaN(n) && !isNaN(epsilon) && !isNaN(phi) && !isNaN(cf) && !isNaN(opCostPerMwh) && !isNaN(emissions) && !isNaN(r)) {
                investment = epsilon * capacity;
                annualGeneration = capacity * cf * 8760;
                annualRevenue = annualGeneration * electricityPrice;
                annualVarCost = annualGeneration * opCostPerMwh;
                annualFixedCost = phi * epsilon * capacity;
                annualCarbonCost = annualGeneration * emissions * carbonPrice;
                annualNetCashFlow = annualRevenue - annualVarCost - annualFixedCost - annualCarbonCost;
                // NPV
                if (r < -1) { npv = NaN; payback = 'Error'; }
                else if (Math.abs(r) < 1e-9) { npv = (annualNetCashFlow * n) - investment; }
                else { const pvFactor = (1 - Math.pow(1 + r, -n)) / r; npv = (annualNetCashFlow * pvFactor) - investment; }

                // Payback Calculation (Simplified "Never")
                if (isNaN(npv)) { payback = 'Error'; }
                else if (annualNetCashFlow <= 1e-9) { payback = 'Never'; }
                else if (investment <= 0) { payback = 0; }
                else {
                    if (Math.abs(r) < 1e-9) { // Simple Payback
                        const simplePayback = investment / annualNetCashFlow;
                        if (simplePayback <= n) payback = simplePayback;
                        else payback = 'Never'; // Simplified
                    } else { // Discounted Payback
                        const term = 1 - (investment * r / annualNetCashFlow);
                        const maxPVFactor = (1 - Math.pow(1 + r, -n)) / r;
                        if (annualNetCashFlow * maxPVFactor < investment - 1e-9 ) {
                            payback = 'Never'; // Simplified
                        }
                        else if (term <= 1e-9) {
                             payback = 'Never';
                        }
                         else {
                            const k = -Math.log(term) / Math.log(1 + r);
                            if (k > 0 && k <= n) payback = k;
                            else if (k > n) payback = 'Never'; // Simplified
                            else payback = 'Error';
                        }
                    }
                }
            } else if (capacity <= 0) { investment = 0; annualNetCashFlow = 0; npv = 0; payback = 'N/A (No Capacity)'; }
            else { investment = (isNaN(epsilon) || isNaN(capacity)) ? NaN : epsilon * capacity; annualNetCashFlow = NaN; npv = isNaN(investment) ? NaN : -investment; payback = 'Error'; }

            // Update result cells
            cells[resultColumnsStart].textContent = formatNumber(investment / 1_000_000);
            cells[resultColumnsStart + 1].textContent = formatNumber(annualNetCashFlow / 1_000_000);
            const npvCell = cells[resultColumnsStart + 2];
            npvCell.textContent = formatNumber(npv / 1_000_000);
            npvCell.classList.remove('positive-npv', 'negative-npv');
            if (!isNaN(npv)) npvCell.classList.add(npv >= 0 ? 'positive-npv' : 'negative-npv');
            cells[resultColumnsStart + 3].textContent = formatPayback(payback); // Displays the calculated payback value
        }


        // --- Event Handlers & UI Logic (Unchanged from previous step) ---

        function updateAllCalculations() { /* ... as before ... */
            let globalsValid = true;
            const elecPriceInput = document.getElementById('electricityPrice');
            const carbonPriceInput = document.getElementById('carbonPrice');
             if (isNaN(parseFloat(elecPriceInput.value))) { globalsValid = false; elecPriceInput.classList.add('invalid-input'); } else { elecPriceInput.classList.remove('invalid-input'); }
             if (isNaN(parseFloat(carbonPriceInput.value))) { globalsValid = false; carbonPriceInput.classList.add('invalid-input'); } else { carbonPriceInput.classList.remove('invalid-input'); }
            const tableBody = document.getElementById('resultsTableBody');
            const rows = tableBody.getElementsByTagName('tr');
             for (const row of rows) {
                 if (globalsValid) { calculateRowResults(row); }
                 else { // Clear results if globals invalid
                     for (let i = resultColumnsStart; i < row.cells.length; i++) {
                         row.cells[i].textContent = 'Error';
                         if (i === resultColumnsStart + 2) row.cells[i].classList.remove('positive-npv', 'negative-npv');
                     }
                 }
             }
        }

        function applyGlobalFixedCostFraction() { /* ... as before ... */
            const fixedCostFractionInput = document.getElementById('fixedCostFraction');
            const newValue = parseFloat(fixedCostFractionInput.value);
            if (isNaN(newValue) || newValue < 0) {
                fixedCostFractionInput.classList.add('invalid-input');
                alert("Please enter a valid non-negative number for Fixed Cost Fraction."); return;
            } else { fixedCostFractionInput.classList.remove('invalid-input'); }
            const formattedValue = formatPhi(newValue);
            const tableBody = document.getElementById('resultsTableBody');
            const rows = tableBody.getElementsByTagName('tr');
            const phiColumnIndex = getParamColumnIndex('phi');
            if (phiColumnIndex === -1) return;
            for (const row of rows) {
                const phiCell = row.cells[phiColumnIndex];
                phiCell.textContent = formattedValue;
                phiCell.classList.remove('invalid-input');
            }
            updateAllCalculations();
        }

        function handleCellEdit(event) { /* ... as before ... */
            const cell = event.target;
            const row = cell.closest('tr');
            const colIndex = cell.cellIndex;
            const correspondingKey = parameterKeysInTableOrder[colIndex];

             if (!correspondingKey || !editableParamKeys.includes(correspondingKey)) {
                 console.warn("Edit event on non-editable/unknown cell:", colIndex); return;
             }

            const rawValue = cell.textContent;
            let value;
            let isInvalid = false;
            let requiresRecalc = true;

            if (correspondingKey === 'max_p_mw 2025' || correspondingKey === 'max_p_mw 2050') {
                value = parseGW(rawValue);
                if (isNaN(value) || value < 0) { isInvalid = true; }
                else { cell.textContent = formatGW(value * 1000); } // Reformat valid input
                if (correspondingKey === 'max_p_mw 2025') requiresRecalc = false;
            } else {
                 value = parseFloat(rawValue.trim().replace(/,/g, ''));
                 if (isNaN(value)) { isInvalid = true; }
                 else if (correspondingKey === 'economic_life' && (!Number.isInteger(value) || value <= 0)) { isInvalid = true; }
                 else if (correspondingKey === 'phi' && value < 0) { isInvalid = true; }
                 else if (correspondingKey === 'CF' && (value < 0 || value > 1)) { isInvalid = true; }
                 if (!isInvalid && correspondingKey === 'phi') cell.textContent = formatPhi(value);
            }
            cell.classList.toggle('invalid-input', isInvalid);
            if (requiresRecalc) calculateRowResults(row);
        }


        function populateTable() { /* ... as before ... */
            const tableBody = document.getElementById('resultsTableBody');
            tableBody.innerHTML = '';
            initialData.forEach((itemData, dataIndex) => {
                const row = tableBody.insertRow();
                row.setAttribute('data-row-index', dataIndex);
                 parameterKeysInTableOrder.forEach((key, keyIndex) => {
                     const cell = row.insertCell();
                     const isEditable = editableParamKeys.includes(key);
                     let displayValue = itemData[key];
                     if (key === 'type') {
                         if (displayValue === 'g2p(Fuel Cell)') { displayValue = 'G2P(Fuel Cell)'; }
                         else if (typesToCapitalize.includes(displayValue)) { displayValue = displayValue.toUpperCase(); }
                         cell.textContent = displayValue;
                     } else if (key === 'max_p_mw 2025' || key === 'max_p_mw 2050') {
                          cell.textContent = formatGW(displayValue);
                          cell.setAttribute('contenteditable', 'true');
                          cell.setAttribute('data-key', key);
                          cell.addEventListener('blur', handleCellEdit);
                          cell.addEventListener('keydown', (event) => { if (event.key === 'Enter') { event.preventDefault(); event.target.blur(); } });
                     } else if (isEditable) {
                         cell.textContent = (key === 'phi') ? formatPhi(displayValue) : displayValue;
                         cell.setAttribute('contenteditable', 'true');
                         cell.setAttribute('data-key', key);
                         cell.addEventListener('blur', handleCellEdit);
                         cell.addEventListener('keydown', (event) => { if (event.key === 'Enter') { event.preventDefault(); event.target.blur(); } });
                     } else { cell.textContent = displayValue; }
                 });
                 for (let i = 0; i < 4; i++) {
                     const cell = row.insertCell(); cell.classList.add('result-col');
                 }
            });
            updateAllCalculations();
        }

        function resetData() { /* ... as before ... */
            if (confirm("Are you sure you want to reset all parameter values and global settings to their defaults?")) {
                 document.getElementById('electricityPrice').value = 100;
                 document.getElementById('carbonPrice').value = 100;
                 document.getElementById('fixedCostFraction').value = 1.0;
                 document.getElementById('electricityPrice').classList.remove('invalid-input');
                 document.getElementById('carbonPrice').classList.remove('invalid-input');
                 document.getElementById('fixedCostFraction').classList.remove('invalid-input');
                 populateTable();
            }
        }

        // Initial setup
        document.addEventListener('DOMContentLoaded', populateTable);

    </script>

</body>
</html>
